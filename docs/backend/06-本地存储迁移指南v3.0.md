# 本地存储迁移指南 v3.0

## 文档信息

- **文档版本**: v3.0
- **产品版本**: v1.0
- **创建日期**: 2025-01-13
- **文档状态**: 已发布

## 说明

本文档指导如何将小程序当前使用的本地存储（wx.getStorageSync/setStorageSync）迁移到后端API，确保平滑过渡，不影响用户体验。

---

## 一、当前本地存储使用情况

### 1.1 本地存储清单

基于前端代码分析，当前使用的本地存储键值：

| 存储键               | 数据类型 | 说明               | 使用位置      |
| -------------------- | -------- | ------------------ | ------------- |
| userInfo             | Object   | 用户基本信息       | 全局使用      |
| accessToken          | String   | 访问令牌           | API请求       |
| refreshToken         | String   | 刷新令牌           | Token刷新     |
| periods              | Array    | 期次列表           | 首页/期次列表 |
| sections\_{periodId} | Array    | 课节列表（按期次） | 课程页        |
| checkins\_{periodId} | Array    | 打卡列表（按期次） | 打卡广场      |
| myCheckins           | Array    | 我的打卡记录       | 个人中心      |
| insights             | Array    | 小凡看见列表       | 个人中心      |
| insightRequests      | Array    | 收到的申请         | 个人中心      |
| enrollments          | Array    | 我的报名记录       | 个人中心      |

### 1.2 当前数据流

```
小程序启动
  ↓
从本地存储读取数据
  ↓
如果有数据：直接展示
如果无数据：显示空状态
  ↓
用户操作（打卡、评论等）
  ↓
更新本地存储
  ↓
刷新页面展示
```

**问题**:

- 数据仅存在本地，换设备后丢失
- 多设备无法同步
- 无法与其他用户互动
- 数据无法统计分析

---

## 二、迁移策略

### 2.1 迁移原则

1. **向后兼容**: 新版本要能处理旧版本的本地数据
2. **平滑过渡**: 用户无感知，自动迁移
3. **数据不丢失**: 迁移失败时保留本地数据
4. **逐步替换**: 按模块逐步替换，降低风险
5. **降级方案**: API失败时仍能使用本地缓存

### 2.2 迁移阶段

**阶段1: 准备阶段（1-2周）**

- 完成后端开发和测试
- 编写数据迁移脚本
- 准备灰度发布方案

**阶段2: 数据迁移（第3周）**

- 用户登录时自动迁移本地数据到服务器
- 保留本地数据作为备份
- 记录迁移日志

**阶段3: 混合模式（第4-5周）**

- API优先，失败时使用本地缓存
- 双写模式：同时更新API和本地存储
- 监控迁移进度

**阶段4: 完全切换（第6周）**

- 移除本地存储写入逻辑
- 仅保留缓存功能
- 清理旧数据

---

## 三、详细迁移方案

### 3.1 用户信息迁移

**当前实现**:

```javascript
// utils/storage.js
const userInfo = wx.getStorageSync('userInfo');

// 登录后保存
wx.setStorageSync('userInfo', {
  id: 1,
  nickname: '阿泰',
  avatar: '泰',
  totalCheckinDays: 23
});
```

**迁移后实现**:

```javascript
// api/user.js
export async function getUserInfo() {
  try {
    const res = await request({
      url: '/users/me',
      method: 'GET'
    });

    // 更新本地缓存
    wx.setStorageSync('userInfo', res.data);

    return res.data;
  } catch (error) {
    // API失败，尝试使用本地缓存
    const cached = wx.getStorageSync('userInfo');
    if (cached) {
      console.warn('Using cached user info');
      return cached;
    }
    throw error;
  }
}

// 更新用户信息
export async function updateUserInfo(data) {
  const res = await request({
    url: '/users/me',
    method: 'PATCH',
    data
  });

  // 更新本地缓存
  const userInfo = wx.getStorageSync('userInfo') || {};
  wx.setStorageSync('userInfo', { ...userInfo, ...res.data });

  return res.data;
}
```

**迁移步骤**:

1. 用户登录时，获取服务器用户信息
2. 如果是新用户，创建账号
3. 如果是老用户，对比本地和服务器数据
4. 以服务器数据为准，更新本地缓存
5. 后续操作直接使用API

### 3.2 期次和课节迁移

**当前实现**:

```javascript
// mock/courses.js
const periods = [
  {
    id: 8,
    name: '勇敢的心'
    // ...
  }
];

const sections = {
  8: [
    {
      id: 802,
      day: 1,
      title: '第一天 品德成功论'
      // ...
    }
  ]
};

// 使用
wx.setStorageSync('periods', periods);
wx.setStorageSync('sections_8', sections[8]);
```

**迁移后实现**:

```javascript
// api/period.js
export async function getPeriods(params = {}) {
  const cacheKey = 'periods';
  const cacheDuration = 15 * 60 * 1000; // 15分钟

  try {
    // 检查缓存
    const cached = getCachedData(cacheKey, cacheDuration);
    if (cached) {
      console.log('Using cached periods');
      // 后台刷新缓存
      refreshPeriodsInBackground();
      return cached;
    }

    // 请求API
    const res = await request({
      url: '/periods',
      method: 'GET',
      data: params
    });

    // 保存缓存
    setCachedData(cacheKey, res.data);

    return res.data;
  } catch (error) {
    // API失败，使用缓存（即使过期）
    const cached = wx.getStorageSync(cacheKey);
    if (cached) {
      console.warn('API failed, using expired cache');
      return cached;
    }
    throw error;
  }
}

// 缓存辅助函数
function getCachedData(key, maxAge) {
  const cached = wx.getStorageSync(key);
  if (!cached) return null;

  const age = Date.now() - (cached.timestamp || 0);
  if (age > maxAge) return null;

  return cached.data;
}

function setCachedData(key, data) {
  wx.setStorageSync(key, {
    data,
    timestamp: Date.now()
  });
}

function refreshPeriodsInBackground() {
  // 后台刷新，不阻塞UI
  setTimeout(async () => {
    try {
      const res = await request({
        url: '/periods',
        method: 'GET'
      });
      setCachedData('periods', res.data);
    } catch (error) {
      console.error('Background refresh failed:', error);
    }
  }, 0);
}
```

**迁移步骤**:

1. 首次启动，从本地读取mock数据（兼容旧版本）
2. 调用API获取最新数据
3. 合并本地和服务器数据（去重）
4. 保存到本地缓存
5. 后续优先使用API，失败时降级到缓存

### 3.3 打卡数据迁移

**当前实现**:

```javascript
// 本地打卡列表
const myCheckins = wx.getStorageSync('myCheckins') || [];

// 创建打卡
function createCheckin(data) {
  const checkin = {
    id: Date.now(),
    ...data,
    createdAt: new Date()
  };

  myCheckins.unshift(checkin);
  wx.setStorageSync('myCheckins', myCheckins);

  return checkin;
}
```

**迁移后实现**:

```javascript
// api/checkin.js
export async function createCheckin(data) {
  try {
    // 调用API
    const res = await request({
      url: '/checkins',
      method: 'POST',
      data
    });

    // 更新本地缓存（添加到列表头部）
    const myCheckins = wx.getStorageSync('myCheckins') || [];
    myCheckins.unshift(res.data);
    wx.setStorageSync('myCheckins', myCheckins);

    // 清除相关缓存
    clearRelatedCache('checkins');

    return res.data;
  } catch (error) {
    // API失败，保存到本地待上传队列
    saveToUploadQueue('checkin', data);
    throw error;
  }
}

// 上传队列处理
function saveToUploadQueue(type, data) {
  const queue = wx.getStorageSync('uploadQueue') || [];
  queue.push({
    type,
    data,
    timestamp: Date.now(),
    retryCount: 0
  });
  wx.setStorageSync('uploadQueue', queue);
}

// 自动重试上传
async function processUploadQueue() {
  const queue = wx.getStorageSync('uploadQueue') || [];
  if (queue.length === 0) return;

  const newQueue = [];

  for (const item of queue) {
    try {
      if (item.type === 'checkin') {
        await request({
          url: '/checkins',
          method: 'POST',
          data: item.data
        });
        console.log('Upload success:', item);
      }
      // 上传成功，不加入新队列
    } catch (error) {
      // 上传失败
      item.retryCount++;
      if (item.retryCount < 3) {
        newQueue.push(item); // 重试次数未达上限，继续保留
      } else {
        console.error('Upload failed after 3 retries:', item);
        // 通知用户数据上传失败
      }
    }
  }

  wx.setStorageSync('uploadQueue', newQueue);
}

// 网络恢复时自动上传
wx.onNetworkStatusChange(res => {
  if (res.isConnected) {
    processUploadQueue();
  }
});
```

**本地打卡数据上传**:

```javascript
// 迁移脚本
async function migrateLocalCheckins() {
  const localCheckins = wx.getStorageSync('myCheckins') || [];

  if (localCheckins.length === 0) {
    console.log('No local checkins to migrate');
    return;
  }

  console.log(`Migrating ${localCheckins.length} local checkins...`);

  const migrated = [];
  const failed = [];

  for (const checkin of localCheckins) {
    try {
      // 检查是否已迁移（根据临时ID或内容判断）
      const isDuplicate = await checkIfCheckinExists(checkin);
      if (isDuplicate) {
        console.log('Checkin already migrated:', checkin.id);
        continue;
      }

      // 上传到服务器
      const res = await request({
        url: '/checkins',
        method: 'POST',
        data: {
          sectionId: checkin.sectionId,
          content: checkin.content,
          images: checkin.images || [],
          visibility: checkin.visibility || 'all',
          // 保留原始创建时间
          createdAt: checkin.createdAt
        }
      });

      migrated.push(res.data);
    } catch (error) {
      console.error('Failed to migrate checkin:', checkin, error);
      failed.push(checkin);
    }
  }

  console.log(`Migration completed: ${migrated.length} success, ${failed.failed} failed`);

  // 保存迁移结果
  wx.setStorageSync('migrationResult', {
    migrated: migrated.length,
    failed: failed.length,
    timestamp: Date.now()
  });

  // 如果全部迁移成功，清除本地数据
  if (failed.length === 0) {
    wx.removeStorageSync('myCheckins');
  }
}

// 检查打卡是否已存在
async function checkIfCheckinExists(localCheckin) {
  try {
    const res = await request({
      url: '/checkins',
      method: 'GET',
      data: {
        sectionId: localCheckin.sectionId,
        userId: 'me'
      }
    });

    // 检查是否有相同内容的打卡
    return res.data.items.some(
      c => c.sectionId === localCheckin.sectionId && c.content === localCheckin.content
    );
  } catch (error) {
    return false;
  }
}
```

### 3.4 小凡看见迁移

**当前实现**:

```javascript
// 本地小凡看见列表
const insights = wx.getStorageSync('insights') || [];
```

**迁移后实现**:

```javascript
// api/insight.js
export async function getMyInsights(params = {}) {
  try {
    const res = await request({
      url: '/users/me/insights',
      method: 'GET',
      data: params
    });

    // 更新缓存
    if (params.page === 1) {
      wx.setStorageSync('insights', res.data.items);
    }

    return res.data;
  } catch (error) {
    // 使用缓存
    if (params.page === 1) {
      const cached = wx.getStorageSync('insights');
      if (cached) return { items: cached };
    }
    throw error;
  }
}

export async function generateInsight(checkinId, visibility = 'private') {
  const res = await request({
    url: '/insights',
    method: 'POST',
    data: { checkinId, visibility }
  });

  // 添加到缓存
  const insights = wx.getStorageSync('insights') || [];
  insights.unshift(res.data);
  wx.setStorageSync('insights', insights);

  return res.data;
}
```

---

## 四、通用迁移模式

### 4.1 API优先模式（推荐）

```javascript
// utils/api-wrapper.js
export async function apiFirst(apiCall, cacheKey, options = {}) {
  const {
    cacheDuration = 5 * 60 * 1000, // 默认5分钟
    forceRefresh = false,
    fallbackToCache = true
  } = options;

  // 强制刷新时跳过缓存
  if (!forceRefresh) {
    const cached = getCachedData(cacheKey, cacheDuration);
    if (cached) {
      // 返回缓存，后台刷新
      if (options.backgroundRefresh) {
        refreshInBackground(apiCall, cacheKey);
      }
      return cached;
    }
  }

  try {
    // 调用API
    const data = await apiCall();

    // 保存缓存
    setCachedData(cacheKey, data);

    return data;
  } catch (error) {
    // API失败
    if (fallbackToCache) {
      // 使用过期缓存
      const cached = wx.getStorageSync(cacheKey);
      if (cached && cached.data) {
        console.warn('API failed, using expired cache');
        return cached.data;
      }
    }
    throw error;
  }
}

// 使用示例
async function getPeriods() {
  return apiFirst(() => request({ url: '/periods', method: 'GET' }), 'periods', {
    cacheDuration: 15 * 60 * 1000,
    backgroundRefresh: true,
    fallbackToCache: true
  });
}
```

### 4.2 双写模式

```javascript
// 创建数据时同时写入API和本地
export async function createWithSync(apiCall, localKey, data) {
  try {
    // 调用API
    const result = await apiCall(data);

    // 更新本地缓存
    const list = wx.getStorageSync(localKey) || [];
    list.unshift(result);
    wx.setStorageSync(localKey, list);

    return result;
  } catch (error) {
    // API失败，只保存到本地
    const tempId = `temp_${Date.now()}`;
    const localData = { ...data, id: tempId, isLocal: true };

    const list = wx.getStorageSync(localKey) || [];
    list.unshift(localData);
    wx.setStorageSync(localKey, list);

    // 加入上传队列
    saveToUploadQueue('create', localKey, data);

    return localData;
  }
}
```

### 4.3 增量同步模式

```javascript
// 增量获取新数据
export async function syncIncremental(apiUrl, localKey) {
  const local = wx.getStorageSync(localKey) || [];
  const lastSyncTime = wx.getStorageSync(`${localKey}_lastSync`) || 0;

  try {
    // 获取最后同步时间之后的数据
    const res = await request({
      url: apiUrl,
      method: 'GET',
      data: {
        since: lastSyncTime,
        limit: 100
      }
    });

    // 合并数据（去重）
    const merged = mergeAndDeduplicate(local, res.data.items);

    // 保存
    wx.setStorageSync(localKey, merged);
    wx.setStorageSync(`${localKey}_lastSync`, Date.now());

    return merged;
  } catch (error) {
    console.error('Incremental sync failed:', error);
    return local;
  }
}

function mergeAndDeduplicate(local, remote) {
  const map = new Map();

  // 远程数据优先
  remote.forEach(item => map.set(item.id, item));

  // 添加本地独有数据
  local.forEach(item => {
    if (!map.has(item.id)) {
      map.set(item.id, item);
    }
  });

  return Array.from(map.values()).sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
}
```

---

## 五、迁移检查清单

### 5.1 迁移前检查

- [ ] 后端API已开发完成并测试通过
- [ ] API文档已更新
- [ ] 前端API封装已完成
- [ ] 数据迁移脚本已编写
- [ ] 降级方案已实现
- [ ] 缓存策略已确定
- [ ] 上传队列机制已实现
- [ ] 错误处理已完善

### 5.2 迁移中监控

- [ ] 监控API成功率
- [ ] 监控数据迁移进度
- [ ] 监控错误日志
- [ ] 收集用户反馈
- [ ] 检查缓存命中率
- [ ] 检查上传队列长度

### 5.3 迁移后验证

- [ ] 所有功能正常工作
- [ ] 数据完整性验证
- [ ] 性能指标达标
- [ ] 无数据丢失
- [ ] 缓存机制工作正常
- [ ] 离线功能可用
- [ ] 多设备同步正常

---

## 六、代码重构示例

### 6.1 重构前（使用本地存储）

```javascript
// pages/profile/profile.js
Page({
  data: {
    userInfo: null,
    todaySection: null,
    recentInsights: []
  },

  onLoad() {
    // 从本地存储读取
    const userInfo = wx.getStorageSync('userInfo');
    const insights = wx.getStorageSync('insights') || [];

    this.setData({
      userInfo,
      recentInsights: insights.slice(0, 5)
    });

    // 获取今日任务
    this.loadTodaySection();
  },

  loadTodaySection() {
    // 从本地mock数据查找
    const periods = wx.getStorageSync('periods') || [];
    const ongoingPeriod = periods.find(p => p.status === 'ongoing');

    if (ongoingPeriod) {
      const sections = wx.getStorageSync(`sections_${ongoingPeriod.id}`) || [];
      const now = new Date();
      const todaySection = sections.find(s => {
        const start = new Date(s.startTime);
        const end = new Date(s.endTime);
        return now >= start && now <= end;
      });

      this.setData({ todaySection });
    }
  }
});
```

### 6.2 重构后（使用API）

```javascript
// pages/profile/profile.js
import { getUserInfo, getUserStats } from '../../api/user';
import { getTodaySections } from '../../api/section';
import { getMyInsights } from '../../api/insight';

Page({
  data: {
    userInfo: null,
    todaySection: null,
    recentInsights: [],
    loading: true
  },

  async onLoad() {
    await this.loadPageData();
  },

  async loadPageData() {
    try {
      wx.showLoading({ title: '加载中...' });

      // 并发请求多个接口
      const [userInfo, todaySections, insights] = await Promise.all([
        getUserInfo(),
        getTodaySections(),
        getMyInsights({ page: 1, pageSize: 5 })
      ]);

      this.setData({
        userInfo,
        todaySection: todaySections[0] || null,
        recentInsights: insights.items || [],
        loading: false
      });

      wx.hideLoading();
    } catch (error) {
      console.error('Load page data failed:', error);
      wx.hideLoading();

      // 尝试使用缓存数据
      this.loadCachedData();

      wx.showToast({
        title: '加载失败，使用缓存数据',
        icon: 'none'
      });
    }
  },

  loadCachedData() {
    const userInfo = wx.getStorageSync('userInfo');
    const insights = wx.getStorageSync('insights') || [];

    this.setData({
      userInfo,
      recentInsights: insights.slice(0, 5),
      loading: false
    });
  },

  // 下拉刷新
  async onPullDownRefresh() {
    await this.loadPageData();
    wx.stopPullDownRefresh();
  }
});
```

---

## 七、性能优化建议

### 7.1 请求合并

```javascript
// 合并多个小请求为一个批量请求
async function batchLoadUserData(userId) {
  // 一次请求获取所有需要的数据
  const res = await request({
    url: `/users/${userId}/dashboard`,
    method: 'GET'
  });

  // 分别缓存
  wx.setStorageSync('userInfo', res.data.userInfo);
  wx.setStorageSync('stats', res.data.stats);
  wx.setStorageSync('todaySections', res.data.todaySections);

  return res.data;
}
```

### 7.2 预加载

```javascript
// app.js
App({
  async onLaunch() {
    // 应用启动时预加载常用数据
    this.preloadCommonData();
  },

  async preloadCommonData() {
    const token = wx.getStorageSync('accessToken');
    if (!token) return;

    // 后台预加载，不阻塞启动
    setTimeout(async () => {
      try {
        // 预加载期次列表
        await getPeriods();

        // 预加载用户信息
        await getUserInfo();

        console.log('Preload completed');
      } catch (error) {
        console.error('Preload failed:', error);
      }
    }, 1000);
  }
});
```

### 7.3 分页加载

```javascript
// 列表页分页加载
Page({
  data: {
    checkins: [],
    page: 1,
    hasMore: true,
    loading: false
  },

  async loadCheckins(page = 1) {
    if (this.data.loading || !this.data.hasMore) return;

    this.setData({ loading: true });

    try {
      const res = await request({
        url: '/checkins',
        method: 'GET',
        data: {
          page,
          pageSize: 20
        }
      });

      const checkins = page === 1 ? res.data.items : [...this.data.checkins, ...res.data.items];

      this.setData({
        checkins,
        page,
        hasMore: res.data.pagination.hasNext,
        loading: false
      });
    } catch (error) {
      this.setData({ loading: false });
      wx.showToast({ title: '加载失败', icon: 'none' });
    }
  },

  // 触底加载更多
  onReachBottom() {
    if (this.data.hasMore && !this.data.loading) {
      this.loadCheckins(this.data.page + 1);
    }
  }
});
```

---

## 八、回滚方案

如果迁移出现严重问题，需要回滚到纯本地存储：

### 8.1 回滚步骤

1. **发布回滚版本**
   - 恢复使用本地存储的代码
   - 移除API调用
   - 保留mock数据

2. **数据处理**
   - 从服务器导出用户数据
   - 转换为本地存储格式
   - 提供数据导入功能

3. **通知用户**
   - 应用内公告
   - 引导用户导入数据

### 8.2 回滚代码示例

```javascript
// 检测是否需要使用降级模式
const USE_FALLBACK_MODE = wx.getStorageSync('useFallbackMode') || false;

// API封装支持降级
export async function request(options) {
  if (USE_FALLBACK_MODE) {
    // 使用本地mock数据
    return getMockData(options.url);
  }

  try {
    // 正常API请求
    return await wx.request(options);
  } catch (error) {
    // API失败，自动降级
    console.warn('API failed, fallback to local mode');
    wx.setStorageSync('useFallbackMode', true);
    return getMockData(options.url);
  }
}
```

---

## 九、迁移时间表

### 9.1 完整时间表（6周）

| 周次  | 阶段 | 主要任务               | 里程碑       |
| ----- | ---- | ---------------------- | ------------ |
| 第1周 | 准备 | 后端开发、API测试      | 后端API上线  |
| 第2周 | 准备 | 前端API封装、迁移脚本  | 前端准备完成 |
| 第3周 | 迁移 | 发布迁移版本、灰度测试 | 10%用户迁移  |
| 第4周 | 混合 | 全量发布、监控数据     | 100%用户迁移 |
| 第5周 | 混合 | 优化性能、修复问题     | 稳定运行     |
| 第6周 | 完成 | 移除本地存储、清理代码 | 迁移完成     |

### 9.2 风险控制

**灰度发布**:

- 第一批: 10%用户（内部测试用户）
- 第二批: 30%用户
- 第三批: 50%用户
- 全量: 100%用户

**回滚触发条件**:

- API成功率 < 95%
- 数据丢失率 > 0.1%
- 用户投诉量激增
- 严重功能异常

---

## 十、FAQ

**Q1: 迁移后本地数据会被删除吗？**
A: 不会立即删除。迁移成功后会保留30天作为备份，确保无误后才清理。

**Q2: 换设备后旧设备的本地数据怎么办？**
A: 每个设备首次登录时都会自动迁移本地数据到服务器，多设备数据会自动合并。

**Q3: 迁移失败会影响使用吗？**
A: 不会。迁移失败时会继续使用本地数据，并在后台自动重试。

**Q4: 网络不好时会有影响吗？**
A: 有缓存机制。首次加载需要网络，后续访问可以使用缓存。创建内容时会保存到上传队列，网络恢复后自动上传。

**Q5: 如何查看迁移进度？**
A: 在个人中心-设置-数据迁移中可以查看迁移状态和进度。

---

**文档版本**: v3.0  
**最后更新**: 2025-01-13  
**文档状态**: 已完成
